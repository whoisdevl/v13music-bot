{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import {\n  randomBytes,\n  pbkdf2Sync,\n  createCipheriv,\n  createDecipheriv,\n} from 'crypto';\n\nconst KEYLEN = 256 / 8; // Because we use aes-256-gcm\n\nclass StringCrypto {\n  static defaultDeriveKeyOpts: DeriveKeyOpts = {\n    salt: 's41t',\n    iterations: 1,\n    digest: 'sha512',\n  };\n\n  private _deriveKeyOptions: DeriveKeyOpts;\n\n  constructor(options?: DeriveKeyOpts) {\n    if (options) {\n      this._deriveKeyOptions = options;\n    }\n  }\n\n  deriveKey = (\n    password: StringLike,\n    options?: DeriveKeyOpts,\n  ) => {\n    const {\n      salt,\n      iterations,\n      digest,\n    } = Object.assign(\n      {},\n      StringCrypto.defaultDeriveKeyOpts,\n      options,\n    );\n\n    return pbkdf2Sync(password, salt, iterations, KEYLEN, digest);\n  };\n\n  encryptString = (\n    str: StringLike,\n    password: StringLike,\n  ): string => {\n    const derivedKey = this.deriveKey(password, this._deriveKeyOptions);\n\n    const randomInitVector = randomBytes(16);\n\n    const aesCBC = createCipheriv('aes-256-gcm', derivedKey, randomInitVector);\n\n    let encryptedBase64 = aesCBC.update(str.toString(), 'utf8', 'base64');\n    encryptedBase64 += aesCBC.final('base64');\n\n    const encryptedHex = Buffer.from(encryptedBase64).toString('hex');\n\n    const initVectorHex = randomInitVector.toString('hex');\n\n    return `${initVectorHex}:${encryptedHex}`;\n  };\n\n  decryptString = (\n    encryptedStr: StringLike,\n    password: StringLike,\n  ): string => {\n    const derivedKey = this.deriveKey(password, this._deriveKeyOptions);\n\n    const encryptedParts: string[] = encryptedStr.toString().split(':');\n\n    if (encryptedParts.length !== 2) {\n      throw new Error(`Incorrect format for encrypted string: ${encryptedStr}`);\n    }\n\n    const [\n      initVectorHex,\n      encryptedHex,\n    ] = encryptedParts;\n\n    const randomInitVector = Buffer.from(initVectorHex, 'hex');\n\n    const encryptedBase64 = Buffer.from(encryptedHex, 'hex').toString();\n\n    const aesCBC = createDecipheriv('aes-256-gcm', derivedKey, randomInitVector);\n\n    let decrypted = aesCBC.update(encryptedBase64, 'base64');\n\n    return decrypted.toString();\n  };\n}\n\nexport default StringCrypto;\n"],"names":["options","this","password","_a","Object","assign","StringCrypto","defaultDeriveKeyOpts","salt","iterations","digest","pbkdf2Sync","str","derivedKey","_this","deriveKey","_deriveKeyOptions","randomInitVector","randomBytes","aesCBC","createCipheriv","encryptedBase64","update","toString","final","encryptedHex","Buffer","from","encryptedStr","encryptedParts","split","length","Error","initVectorHex","createDecipheriv"],"mappings":"kDAkBE,WAAYA,GAAZ,WAMAC,eAAY,SACVC,EACAF,GAEM,IAAAG,EAIFC,OAAOC,OACT,GACAC,EAAaC,qBACbP,GANAQ,SACAC,eACAC,WAOF,OAAOC,aAAWT,EAAUM,EAAMC,EA/BvB,GA+B2CC,IAGxDT,mBAAgB,SACdW,EACAV,GAEA,IAAMW,EAAaC,EAAKC,UAAUb,EAAUY,EAAKE,mBAE3CC,EAAmBC,cAAY,IAE/BC,EAASC,iBAAe,cAAeP,EAAYI,GAErDI,EAAkBF,EAAOG,OAAOV,EAAIW,WAAY,OAAQ,UAC5DF,GAAmBF,EAAOK,MAAM,UAEhC,IAAMC,EAAeC,OAAOC,KAAKN,GAAiBE,SAAS,OAI3D,OAFsBN,EAAiBM,SAAS,WAErBE,GAG7BxB,mBAAgB,SACd2B,EACA1B,GAEA,IAAMW,EAAaC,EAAKC,UAAUb,EAAUY,EAAKE,mBAE3Ca,EAA2BD,EAAaL,WAAWO,MAAM,KAE/D,GAA8B,IAA1BD,EAAeE,OACjB,MAAM,IAAIC,MAAM,0CAA0CJ,GAI1D,IAAAK,EAEEJ,KADFJ,EACEI,KAEEZ,EAAmBS,OAAOC,KAAKM,EAAe,OAE9CZ,EAAkBK,OAAOC,KAAKF,EAAc,OAAOF,WAMzD,OAJeW,mBAAiB,cAAerB,EAAYI,GAEpCK,OAAOD,EAAiB,UAE9BE,YAnEbvB,IACFC,KAAKe,kBAAoBhB,GAoE/B,OA9ESM,uBAAsC,CAC3CE,KAAM,OACNC,WAAY,EACZC,OAAQ"}